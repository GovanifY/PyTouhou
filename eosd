#!/usr/bin/env python2
# -*- encoding: utf-8 -*-
##
## Copyright (C) 2011 Thibaut Girka <thib@sitedethib.com>
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published
## by the Free Software Foundation; version 3 only.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##

import argparse
import os


pathsep = os.path.pathsep
default_data = (pathsep.join(('CM.DAT', 'th06*_CM.DAT', '*CM.DAT', '*cm.dat')),
                pathsep.join(('ST.DAT', 'th6*ST.DAT', '*ST.DAT', '*st.dat')),
                pathsep.join(('IN.DAT', 'th6*IN.DAT', '*IN.DAT', '*in.dat')),
                pathsep.join(('MD.DAT', 'th6*MD.DAT', '*MD.DAT', '*md.dat')),
                pathsep.join(('102h.exe', '102*.exe', '東方紅魔郷.exe', '*.exe')))


parser = argparse.ArgumentParser(description='Libre reimplementation of the Touhou 6 engine.')

parser.add_argument('data', metavar='DAT', default=default_data, nargs='*', help='Game’s data files')
parser.add_argument('-p', '--path', metavar='DIRECTORY', default='.', help='Game directory path.')
parser.add_argument('-s', '--stage', metavar='STAGE', type=int, default=None, help='Stage, 1 to 7 (Extra).')
parser.add_argument('-r', '--rank', metavar='RANK', type=int, default=0, help='Rank, from 0 (Easy, default) to 3 (Lunatic).')
parser.add_argument('-c', '--character', metavar='CHARACTER', type=int, default=0, help='Select the character to use, from 0 (ReimuA, default) to 3 (MarisaB).')
parser.add_argument('--replay', metavar='REPLAY', help='Select a replay')
parser.add_argument('--save-replay', metavar='REPLAY', help='Save the upcoming game into a replay file')
parser.add_argument('--skip-replay', action='store_true', help='Skip the replay and start to play when it’s finished')
parser.add_argument('-b', '--boss-rush', action='store_true', help='Fight only bosses')
parser.add_argument('--single-buffer', action='store_true', help='Disable double buffering')
parser.add_argument('--fps-limit', metavar='FPS', default=-1, type=int, help='Set fps limit. A value of 0 disables fps limiting, while a negative value limits to 60 fps if and only if vsync doesn’t work.')
parser.add_argument('--debug', action='store_true', help='Set unlimited continues, and perhaps other debug features.')
parser.add_argument('--fixed-pipeline', action='store_true', help='Use the fixed pipeline instead of the new programmable one.')
parser.add_argument('--no-background', action='store_false', help='Disable background display (huge performance boost on slow systems).')
parser.add_argument('--no-particles', action='store_false', help='Disable particles handling (huge performance boost on slow systems).')
parser.add_argument('--no-music', action='store_false', help='Disable background music.')
parser.add_argument('--hints', metavar='HINTS', default=None, help='Hints file, to display text while playing.')
parser.add_argument('--verbosity', metavar='VERBOSITY', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'], help='Select the wanted logging level.')
parser.add_argument('--game', metavar='GAME', choices=['EoSD'], default='EoSD', help='Select the game engine to use.')
parser.add_argument('--port', metavar='PORT', type=int, default=0, help='Local port to use for netplay')
parser.add_argument('--remote', metavar='REMOTE', default=None, help='Remote address')

args = parser.parse_args()


import sys
import logging

from pytouhou.lib.sdl import SDL
from pytouhou.ui.window import Window
from pytouhou.resource.loader import Loader
from pytouhou.ui.gamerunner import GameRunner
from pytouhou.game.player import PlayerState, GameOver
from pytouhou.formats.t6rp import T6RP, Level
from pytouhou.utils.random import Random
from pytouhou.vm.msgrunner import NextStage
from pytouhou.formats.hint import Hint
from pytouhou.network import Network


if args.game == 'EoSD':
    from pytouhou.games.eosd import EoSDCommon as Common, EoSDGame as Game


class GameBossRush(Game):
    def run_iter(self, keystate):
        for i in range(20):
            skip = not (self.enemies or self.items or self.lasers
                        or self.bullets or self.cancelled_bullets)
            if skip:
                keystate &= ~1
            Game.run_iter(self, keystate | 256 if i == 0 else 0)
            if not self.enemies and self.frame % 90 == 0:
                for player in self.players:
                    if player.state.power < 128:
                        player.state.power += 1
            if not skip:
                break

    def cleanup(self):
        boss_wait = any(ecl_runner.boss_wait for ecl_runner in self.ecl_runners)
        if not (self.boss or self.msg_wait or boss_wait):
            self.enemies = [enemy for enemy in self.enemies
                            if enemy.boss_callback != -1 or enemy.frame > 1]
            self.lasers = [laser for laser in self.lasers if laser.frame > 1]
            self.effects = [effect for effect in self.effects
                            if not hasattr(effect, '_laser')
                            or effect._laser in self.lasers]
            self.bullets = [bullet for bullet in self.bullets if bullet.frame > 1]
        Game.cleanup(self)


def main(window, path, data, stage_num, rank, character, replay, save_filename,
         skip_replay, boss_rush, debug, enable_background, enable_particles,
         enable_music, hints, verbosity, port, remote):

    resource_loader = Loader(path)

    try:
        resource_loader.scan_archives(data)
    except IOError:
        sys.stderr.write('Some data files were not found, did you forget the -p option?\n')
        exit(1)

    if stage_num is None:
        story = True
        stage_num = 1
        continues = 3
    else:
        story = False
        continues = 0

    if debug:
        if not verbosity:
            verbosity = 'DEBUG'
        continues = -1  # Infinite lives

    if verbosity:
        logging.basicConfig(level=logging.__getattribute__(verbosity))

    if replay:
        with open(replay, 'rb') as file:
            replay = T6RP.read(file)
        rank = replay.rank
        character = replay.character

    save_keystates = None
    if save_filename:
        save_replay = T6RP()
        save_replay.rank = rank
        save_replay.character = character

    difficulty = 16
    default_power = [0, 64, 128, 128, 128, 128, 0][stage_num - 1]

    if port != 0:
        if remote:
            remote_addr, remote_port = remote.split(':')
            addr = remote_addr, int(remote_port)
            selected_player = 0
        else:
            addr = None
            selected_player = 1

        prng = Random(0)
        con = Network(port, addr, selected_player)
        states = [PlayerState(character=1, power=default_power, continues=continues),
                  PlayerState(character=3, power=default_power, continues=continues)]
    else:
        con = None
        selected_player = 0
        states = [PlayerState(character=character, power=default_power, continues=continues)]

    if hints:
        with open(hints, 'rb') as file:
            hints = Hint.read(file)

    game_class = GameBossRush if boss_rush else Game

    common = Common(resource_loader, states[selected_player])
    runner = GameRunner(window, resource_loader, skip=skip_replay, con=con)
    while True:
        if replay:
            level = replay.levels[stage_num - 1]
            if not level:
                raise Exception

            prng = Random(level.random_seed)

            #TODO: apply the replay to the other players.
            #TODO: see if the stored score is used or if it’s the one from the previous stage.
            if stage_num != 1 and stage_num - 2 in replay.levels:
                previous_level = replay.levels[stage_num - 1]
                states[0].score = previous_level.score
                states[0].effective_score = previous_level.score
            states[0].points = level.point_items
            states[0].power = level.power
            states[0].lives = level.lives
            states[0].bombs = level.bombs
            difficulty = level.difficulty
        elif port == 0:
            prng = Random()

        if save_filename:
            if not replay:
                save_replay.levels[stage_num - 1] = level = Level()
                level.score = states[0].score
                level.random_seed = prng.seed
                level.point_items = states[0].points
                level.power = states[0].power
                level.lives = states[0].lives
                level.bombs = states[0].bombs
                level.difficulty = difficulty
            save_keystates = []

        hints_stage = hints.stages[stage_num - 1] if hints else None

        game = game_class(resource_loader, states, stage_num, rank, difficulty, common, prng=prng, hints=hints_stage)

        if not enable_particles:
            def new_particle(pos, anim, amp, number=1, reverse=False, duration=24):
                pass
            game.new_particle = new_particle

        background = game.background if enable_background else None
        bgms = game.std.bgms if enable_music else None

        # Main loop
        runner.load_game(game, background, bgms, replay, save_keystates)
        window.set_runner(runner)
        try:
            window.run()
            break
        except NextStage:
            if not story or stage_num == (7 if boss_rush else 6 if rank > 0 else 5):
                break
            stage_num += 1
            states = [player.state for player in game.players]
        except GameOver:
            print('Game over')
            break
        finally:
            if save_filename:
                last_key = -1
                for time, key in enumerate(save_keystates):
                    if key != last_key:
                        level.keys.append((time, key, 0))
                    last_key = key

    window.set_runner(None)

    if save_filename:
        with open(save_filename, 'wb+') as file:
            save_replay.write(file)


with SDL():
    window = Window(double_buffer=(not args.single_buffer),
                    fps_limit=args.fps_limit,
                    fixed_pipeline=args.fixed_pipeline)

    main(window, args.path, tuple(args.data), args.stage, args.rank,
         args.character, args.replay, args.save_replay, args.skip_replay,
         args.boss_rush, args.debug, args.no_background, args.no_particles,
         args.no_music, args.hints, args.verbosity, args.port, args.remote)

    import gc
    gc.collect()
